<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Homework 5</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <style>
        body {
            font-family: 'Montserrat', sans-serif;
            font-style: normal;
            font-weight: 400;
            font-size: 19px;
            line-height: 28px;
            color: #1c1c1c;
        }
        h1 {
            font-family: 'Montserrat', sans-serif;
            font-size: 36px;
            color: #095f7a;
            font-weight: bold;
        }
        h2 {
            font-family: 'Montserrat', sans-serif;
            font-size: 24px;
            color: #095f7a;
            font-weight: bold;
            margin-top: 40px;
        }
        p {
            margin-bottom: 20px;
        }
        strong {
            font-weight: bold;
        }
        html, body {
            margin: 0;
            padding: 0;
        }
        .container {
            text-align: center;
            margin: 0 auto;
            max-width: 1200px;
        }
        #graphCanvas {
            width: 98%;
            height: 400px;
            margin: 0 auto;
            display: block;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: nowrap;
            gap: 10px;
            margin-bottom: 20px;
            padding: 10px;
        }
        .controls label {
            margin: 0 5px 0 0;
        }
        .controls input {
            width: 100px;
            margin-right: 10px;
        }
        .controls button {
            margin-left: 10px;
        }
        @media (max-width: 1000px) {
            .controls {
                flex-wrap: wrap;
            }
            .controls button {
                margin-top: 10px;
            }
        }
    </style>
</head>
<body>
    <br>
    <h1>Cauchy-Schwarz Inequality</h1>
    <p>
        The Cauchy-Schwarz inequality states that for any real numbers \( \{a_i\} \) and \( \{b_i\} \):
    </p>
    <p>
        \[
        \left( \sum_{i=1}^n a_i b_i \right)^2 \leq \left( \sum_{i=1}^n a_i^2 \right) \left( \sum_{i=1}^n b_i^2 \right)
        \]
    </p>
    <p>
        In our case, we let:
    </p>
    <p>
        \[
        a_i = x_i - \bar{x}, \quad b_i = y_i - \bar{y}
        \]
    </p>
    <h2>Proof:</h2>
    <p>
        Consider the quadratic function in \( t \):
    </p>
    <p>
        \[
        f(t) = \sum_{i=1}^n (a_i - t b_i)^2
        \]
    </p>
    <p>
        Since \( f(t) \geq 0 \) for all real \( t \), the discriminant of this quadratic must be less than or equal to zero.
    </p>
    <p>
        First, expand \( f(t) \):
    </p>
    <p>
        \[
        f(t) = \sum_{i=1}^n \left( a_i^2 - 2 t a_i b_i + t^2 b_i^2 \right) = \sum_{i=1}^n a_i^2 - 2 t \sum_{i=1}^n a_i b_i + t^2 \sum_{i=1}^n b_i^2
        \]
    </p>
    <p>
        We can write \( f(t) \) as a quadratic in \( t \):
    </p>
    <p>
        \[
        f(t) = A t^2 - 2 B t + C
        \]
    </p>
    <p>
        Where:
    </p>
    <p>
        \[
        A = \sum_{i=1}^n b_i^2, \quad B = \sum_{i=1}^n a_i b_i, \quad C = \sum_{i=1}^n a_i^2
        \]
    </p>
    <p>
        Since \( f(t) \geq 0 \) for all \( t \), the discriminant \( \Delta \) must satisfy:
    </p>
    <p>
        \[
        \Delta = (-2B)^2 - 4AC \leq 0
        \]
    </p>
    <p>
        Simplify the discriminant:
    </p>
    <p>
        \[
        4B^2 - 4AC \leq 0 \implies B^2 \leq AC
        \]
    </p>
    <p>
        Therefore, we obtain the Cauchy-Schwarz inequality:
    </p>
    <p>
        \[
        \left( \sum_{i=1}^n a_i b_i \right)^2 \leq \left( \sum_{i=1}^n a_i^2 \right) \left( \sum_{i=1}^n b_i^2 \right)
        \]
    </p>
    <h2>Normalization of Covariance</h2>
    <p>
        The covariance between two variables \( X \) and \( Y \) is defined as:
    </p>
    <p>
        \[
        \text{cov}(X,Y) = \frac{1}{n} \sum_{i=1}^n (x_i - \bar{x})(y_i - \bar{y})
        \]
    </p>
    <p>
        To normalize the covariance between -1 and 1, we divide it by the maximum possible value:
    </p>
    <p>
        \[
        r = \frac{ \text{cov}(X,Y) }{ \text{MAX} }
        \]
    </p>
    <p>
        Where the maximum is the product of the standard deviations:
    </p>
    <p>
        \[
        \text{MAX} = \sigma_x \sigma_y = \sqrt{ \frac{1}{n} \sum_{i=1}^n (x_i - \bar{x})^2 } \sqrt{ \frac{1}{n} \sum_{i=1}^n (y_i - \bar{y})^2 }
        \]
    </p>
    <h2>Application of Cauchy-Schwarz inequality to covariance and correlation</h2>
    <p>
        Applying the inequality to our definitions of \( a_i \) and \( b_i \):
    </p>
    <p>
        \[
        \left( \sum_{i=1}^n (x_i - \bar{x})(y_i - \bar{y}) \right)^2 \leq \left( \sum_{i=1}^n (x_i - \bar{x})^2 \right) \left( \sum_{i=1}^n (y_i - \bar{y})^2 \right)
        \]
    </p>
    <p>
        Dividing both sides by \( n^2 \):
    </p>
    <p>
        \[
        \left( \frac{1}{n} \sum_{i=1}^n (x_i - \bar{x})(y_i - \bar{y}) \right)^2 \leq \left( \frac{1}{n} \sum_{i=1}^n (x_i - \bar{x})^2 \right) \left( \frac{1}{n} \sum_{i=1}^n (y_i - \bar{y})^2 \right)
        \]
    </p>
    <p>
        Recognizing that:
    </p>
    <p>
        \[
        \text{cov}(X,Y) = \frac{1}{n} \sum_{i=1}^n (x_i - \bar{x})(y_i - \bar{y}), \quad \sigma_x^2 = \frac{1}{n} \sum_{i=1}^n (x_i - \bar{x})^2, \quad \sigma_y^2 = \frac{1}{n} \sum_{i=1}^n (y_i - \bar{y})^2
        \]
    </p>
    <p>
        The inequality becomes:
    </p>
    <p>
        \[
        \text{cov}(X,Y)^2 \leq \sigma_x^2 \sigma_y^2
        \]
    </p>
    <p>
        Taking the square root of both sides:
    </p>
    <p>
        \[
        | \text{cov}(X,Y) | \leq \sigma_x \sigma_y
        \]
    </p>
    <p>
        Therefore, the correlation coefficient \( r \) satisfies:
    </p>
    <p>
        \[
        | r | = \left| \frac{ \text{cov}(X,Y) }{ \sigma_x \sigma_y } \right| \leq 1
        \]
    </p>
    <h2>Concepts of independence and uncorrelation</h2>
    <p>
        When we talk about the relationship between two random variables, it is crucial to understand the difference between <strong>independence</strong> and <strong>uncorrelation</strong>. These concepts are related but not equivalent.
    </p>
    <p>
        <strong>Independence</strong> between two variables \( X \) and \( Y \) means that the value of one variable does not provide any information about the value of the other. Mathematically, two variables are independent if their joint probability distribution can be written as the product of their marginal distributions. Independence implies that the behavior of one variable has no effect on the behavior of the other.
    </p>
    <p>
        On the other hand, <strong>uncorrelation</strong> is a weaker condition that is specifically related to the linear relationship between two variables. Two variables \( X \) and \( Y \) are said to be uncorrelated if their covariance is zero:
    </p>
    <p>
        \[
        \text{cov}(X, Y) = 0
        \]
    </p>
    <p>
        Uncorrelation means that there is no linear relationship between the two variables, but it does not necessarily imply that the variables are independent. In other words, uncorrelated variables might still exhibit a nonlinear relationship.
    </p>
    <h2>Differences and measures</h2>
    <p>
        Let's recall some useful definitions:
    </p>
    <ul>
        <li>
            <strong>Variance:</strong> This is a measure of how much a single variable deviates from its mean. It is defined as:
            \[
            \text{Var}(X) = \frac{1}{m} \sum_{i=1}^m (x_i - \bar{x})^2
            \]
        </li>
        <li>
            <strong>Covariance:</strong> This measures how two variables deviate together, given by the formula:
            \[
            \text{cov}(X, Y) = \frac{1}{n} \sum_{i=1}^n (x_i - \bar{x})(y_i - \bar{y})
            \]
            A positive covariance indicates that both variables tend to grow or diminish together, whereas a negative covariance suggests that as one variable grows, the other tends to diminish.
        </li>
    </ul>
    <p>
        In a <strong>univariate context</strong>, variance is used to measure the dispersion of a single variable, while in a <strong>bivariate context</strong>, covariance (or more generally correlation) is used to measure the relationship between two variables.
    </p>
    <p>
        Importantly, <strong>independence implies uncorrelation</strong>, but the reverse is not necessarily true. Two independent variables will always have a covariance of zero because their joint distribution factors into their marginals, ensuring no linear dependence. However, uncorrelated variables can still be related in a more complex, nonlinear manner. 
    </p>
    <p>
        For example, consider two variables \( X \) and \( Y \) where \( Y = X^2 \). In this case, \( X \) and \( Y \) are clearly related, but their covariance can still be zero since their relationship is not linear.
    </p>

    <h1 style="text-align: center;">Unified SDE Simulator</h1>
    <div class="container">
        <div class="controls">
            <label for="versionSelect">Select version:</label>
            <select id="versionSelect">
                <option value="1">Bernoulli process</option>
                <option value="2">Random walk</option>
                <option value="3">Poisson process</option>
                <option value="4">Brownian motion</option>
            </select>
        </div>
        <div id="controlsContainer">
            <!-- Controls will be injected here -->
        </div>
        <canvas id="graphCanvas"></canvas>
    </div>

    <script>
        var canvas = document.getElementById('graphCanvas');
        var ctx = canvas.getContext('2d');

        // Set canvas dimensions
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;

        function clearCanvas() {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Fill the canvas with a white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function setupVersion1() {
            var controlsContainer = document.getElementById('controlsContainer');
            controlsContainer.innerHTML = `
                <div class="controls">
                    <label for="m">Number of hackers:</label>
                    <input type="number" id="m" class="form-control" value="5">
                    <label for="n">Number of servers:</label>
                    <input type="number" id="n" class="form-control" value="10">
                    <label for="p">Probability of penetration:</label>
                    <input type="number" id="p" class="form-control" step="0.1" value="0.3">
                    <button class="btn btn-primary" onclick="generateChartVersion1()">Start Simulation</button>
                </div>
            `;
            clearCanvas();
        }

        function setupVersion2() {
            var controlsContainer = document.getElementById('controlsContainer');
            controlsContainer.innerHTML = `
                <div class="controls">
                    <label for="numSimulations">Number of hackers:</label>
                    <input class="form-control" type="number" id="numSimulations" value="100">
                    <label for="numSteps">Number of servers:</label>
                    <input class="form-control" type="number" id="numSteps" value="100">
                    <label for="probability">Probability of penetration:</label>
                    <input class="form-control" type="number" id="probability" step="0.01" value="0.5">
                    <label for="intermediateStep">Relative frequency (k):</label>
                    <input class="form-control" type="number" id="intermediateStep" value="50">
                    <button type="button" class="btn btn-primary" onclick="runSimulationVersion2()">Run Simulation</button>
                </div>
            `;
            clearCanvas();
        }

        function setupVersion3() {
            var controlsContainer = document.getElementById('controlsContainer');
            controlsContainer.innerHTML = `
                <div class="controls">
                    <label for="numSimulations">Number of hackers:</label>
                    <input class="form-control" type="number" id="numSimulations" value="200">
                    <label for="numSteps">Number of intervals:</label>
                    <input class="form-control" type="number" id="numSteps" value="10000" style="width: 120px;">
                    <label for="lambda">Lambda parameter:</label>
                    <input class="form-control" type="number" id="lambda" step="1" value="100">
                    <label for="intermediateStep">Relative frequency (k):</label>
                    <input class="form-control" type="number" id="intermediateStep" value="5000">
                    <button type="button" class="btn btn-primary" onclick="runSimulationVersion3()">Run Simulation</button>
                </div>
            `;
            clearCanvas();
        }

        function setupVersion4() {
            var controlsContainer = document.getElementById('controlsContainer');
            controlsContainer.innerHTML = `
                <div class="controls">
                    <label for="numSimulations">Number of simulations:</label>
                    <input class="form-control" type="number" id="numSimulations" value="200">
                    <label for="numSteps">Number of intervals (m):</label>
                    <input class="form-control" type="number" id="numSteps" value="10000" style="width: 120px;">
                    <label for="probabilityP">Probability p:</label>
                    <input class="form-control" type="number" id="probabilityP" step="0.01" value="0.5">
                    <label for="intermediateStep">Intermediate step (k):</label>
                    <input class="form-control" type="number" id="intermediateStep" value="5000">
                    <button type="button" class="btn btn-primary" onclick="runSimulationVersion4()">Run Simulation</button>
                </div>
            `;
            clearCanvas();
        }

        // ------------------- VERSION 1 (Bernoulli process) -------------------

        function generateChartVersion1() {
            clearCanvas();

            var mean = 0;
            var count = 0;
            // Read input values from the form
            var numServers = parseInt(document.getElementById('n').value);
            var numHackers = parseInt(document.getElementById('m').value);
            var penetrationProbability = parseFloat(document.getElementById('p').value);

            // Margins for the chart
            var leftMargin = 80;
            var bottomMargin = 60;
            var topMargin = 60;
            var rightMargin = 80;

            // Usable width and height of the canvas
            var usableWidth = canvas.width - leftMargin - rightMargin;
            var usableHeight = canvas.height - topMargin - bottomMargin;
            var penetrationWidth = (2 / 3) * usableWidth;
            var histogramWidth = usableWidth - penetrationWidth;

            // Simulate the attacks
            var attacks = [];
            var i, j;
            for (i = 0; i < numHackers; i++) {
                var hackerAttempts = [];
                for (j = 0; j < numServers; j++) {
                    var randValue = Math.random();
                    if (randValue < penetrationProbability) {
                        hackerAttempts.push(1); // Successful penetration
                    } else {
                        hackerAttempts.push(0); // Failed penetration
                    }
                }
                attacks.push(hackerAttempts);
            }

            // Calculate the levels reached by each hacker for the histogram
            var levelCounts = [];
            for (i = 0; i <= numServers; i++) {
                levelCounts[i] = 0;
            }

            for (i = 0; i < numHackers; i++) {
                var level = 0;
                for (j = 0; j < numServers; j++) {
                    if (attacks[i][j] === 1) {
                        level++;
                    }
                }
                levelCounts[level]++;
                // Calculate the mean incrementally
                count++;
                var diff = level - mean;
                mean = mean + diff / count;
            }

            // Draw the average penetrations text inside the canvas
            ctx.font = '16px Arial';
            ctx.fillStyle = 'black';
            ctx.textAlign = 'center';
            ctx.fillText('The average of penetrations is: ' + mean.toFixed(2), canvas.width / 2, 30);

            // Draw the penetration chart
            drawChartVersion1(
                ctx,
                attacks,
                numServers,
                numHackers,
                leftMargin,
                bottomMargin,
                topMargin,
                penetrationWidth,
                usableHeight
            );

            // Draw the histogram
            drawHistogramVersion1(
                ctx,
                levelCounts,
                numServers,
                leftMargin,
                bottomMargin,
                topMargin,
                penetrationWidth,
                histogramWidth,
                usableHeight
            );
        }

        function drawChartVersion1(ctx, attacks, numServers, numHackers, leftMargin, bottomMargin, topMargin, penetrationWidth, usableHeight) {
            var heightStep = usableHeight / (numServers + 1);
            var colors = ['red', 'green', 'blue', 'orange', 'purple', 'cyan', 'magenta', 'brown', 'pink', 'teal'];

            // Draw the chart axes
            ctx.beginPath();
            ctx.moveTo(leftMargin, ctx.canvas.height - bottomMargin); // X-axis
            ctx.lineTo(leftMargin + penetrationWidth, ctx.canvas.height - bottomMargin);
            ctx.moveTo(leftMargin, ctx.canvas.height - bottomMargin); // Y-axis
            ctx.lineTo(leftMargin, topMargin);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Add ticks on the x-axis (servers)
            ctx.font = '12px Arial';
            ctx.fillStyle = 'black';
            var xTickInterval = Math.ceil(numServers / 20);
            var j;
            for (j = 0; j <= numServers; j++) {
                var x = leftMargin + j * (penetrationWidth / numServers);
                ctx.beginPath();
                ctx.moveTo(x, ctx.canvas.height - bottomMargin);
                ctx.lineTo(x, ctx.canvas.height - bottomMargin + 5);
                ctx.stroke();

                if (j % xTickInterval === 0 || j === numServers) {
                    ctx.textAlign = 'center';
                    ctx.fillText(j, x, ctx.canvas.height - bottomMargin + 20);
                }
            }

            // Add ticks on the y-axis (penetration levels)
            ctx.textAlign = 'right';
            var yTickInterval = Math.ceil((numServers + 1) / 10);
            var k;
            for (k = 0; k <= numServers; k++) {
                var y = ctx.canvas.height - bottomMargin - k * heightStep;
                ctx.beginPath();
                ctx.moveTo(leftMargin, y);
                ctx.lineTo(leftMargin - 5, y);
                ctx.stroke();

                if (k % yTickInterval === 0 || k === numServers) {
                    ctx.fillText(k, leftMargin - 10, y + 4);
                }
            }

            // Label x-axis
            ctx.textAlign = 'center';
            ctx.font = '14px Arial';
            ctx.fillText('Servers', leftMargin + penetrationWidth / 2, ctx.canvas.height - bottomMargin + 40);

            // Label y-axis
            ctx.save();
            ctx.translate(leftMargin - 45, ctx.canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Penetration Level', 0, 0);
            ctx.restore();

            // Draw the penetration lines for each hacker
            var i;
            for (i = 0; i < numHackers; i++) {
                var color = colors[i % colors.length];
                ctx.strokeStyle = color;
                ctx.beginPath();

                var xPos = leftMargin;
                var yPos = ctx.canvas.height - bottomMargin;
                ctx.moveTo(xPos, yPos);

                for (j = 0; j < numServers; j++) {
                    if (attacks[i][j] === 1) {
                        // go up by one level
                        ctx.lineTo(xPos, yPos - heightStep);
                        yPos -= heightStep;
                    }
                    xPos += (penetrationWidth / numServers);
                    ctx.lineTo(xPos, yPos);
                }
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function drawHistogramVersion1(ctx, levelCounts, numServers, leftMargin, bottomMargin, topMargin, penetrationWidth, histogramWidth, usableHeight) {
            var baseX = leftMargin + penetrationWidth + 20;
            var barHeight = (usableHeight / (numServers + 1)) - 10;

            // Draw the histogram axis
            ctx.beginPath();
            ctx.moveTo(baseX, ctx.canvas.height - bottomMargin);
            ctx.lineTo(baseX, topMargin);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();

            var yTickInterval = Math.ceil((numServers + 1) / 10);
            ctx.font = '12px Arial';
            ctx.fillStyle = 'black';
            ctx.textAlign = 'right';

            var k;
            for (k = 0; k <= numServers; k++) {
                var y = ctx.canvas.height - bottomMargin - (k * (usableHeight / (numServers + 1)));
                ctx.beginPath();
                ctx.moveTo(baseX, y);
                ctx.lineTo(baseX - 5, y);
                ctx.stroke();

                if (k % yTickInterval === 0 || k === numServers) {
                    ctx.fillText(k, baseX - 10, y + 4);
                }
            }

            // Find the maximum count
            var maxCount = 0;
            var i;
            for (i = 0; i < levelCounts.length; i++) {
                if (levelCounts[i] > maxCount) {
                    maxCount = levelCounts[i];
                }
            }

            // Draw the histogram bars
            for (i = 0; i <= numServers; i++) {
                var countVal = levelCounts[i];
                if (countVal > 0) {
                    var yBar = ctx.canvas.height - bottomMargin - (i * (usableHeight / (numServers + 1))) - barHeight / 2;
                    var barWidth = 0;
                    if (maxCount > 0) {
                        barWidth = (countVal / maxCount) * (histogramWidth - 20);
                    }

                    ctx.fillStyle = 'lightblue';
                    ctx.fillRect(baseX, yBar - barHeight / 2, barWidth, barHeight);

                    ctx.fillStyle = 'black';
                    ctx.fillText(countVal.toString(), baseX + barWidth + 10, yBar + 4);
                }
            }
        }

        // ------------------- VERSION 2 (Random walk) -------------------

        function runSimulationVersion2() {
            clearCanvas();

            var n = parseInt(document.getElementById('numSimulations').value);
            var m = parseInt(document.getElementById('numSteps').value);
            var p = parseFloat(document.getElementById('probability').value);
            var k = parseInt(document.getElementById('intermediateStep').value);

            var marginLeft = 50;
            var marginRight = 150;
            var marginTop = 50;
            var marginBottom = 50;

            var plotWidth = canvas.width - marginLeft - marginRight;
            var plotHeight = canvas.height - marginTop - marginBottom;

            var xStep = plotWidth / m;

            // Generate colors
            var colors = [];
            var i;
            for (i = 0; i < n; i++) {
                var hue = (i * 360) / n;
                var colorStr = 'hsl(' + hue + ', 100%, 50%)';
                colors.push(colorStr);
            }

            var finalValues = [];
            var intermediateValues = [];

            // For running mean and variance
            var mean = 0;
            var delta = 0;
            var deviance = 0;

            var maxAbsValue = 0;
            var minAbsValue = 0;
            var trajectories = [];

            var sim;
            for (sim = 0; sim < n; sim++) {
                var X = [];
                X[0] = 0;
                var step;
                for (step = 1; step <= m; step++) {
                    var randVal = Math.random();
                    var jump;
                    if (randVal < p) {
                        jump = 1;
                    } else {
                        jump = -1;
                    }
                    var Xnew = X[step - 1] + jump;
                    X[step] = Xnew;

                    if (Xnew > maxAbsValue) {
                        maxAbsValue = Xnew;
                    }
                    if (Xnew < minAbsValue) {
                        minAbsValue = Xnew;
                    }
                }
                trajectories.push(X);

                finalValues.push(X[m]);
                intermediateValues.push(X[k]);

                var level = X[m];
                var countSoFar = sim + 1;
                delta = level - mean;
                mean = mean + (delta / countSoFar);
                deviance = deviance + (delta * (level - mean));
            }

            var variance = deviance / n;

            // Mean/variance for intermediate values
            var sum_k = 0;
            for (i = 0; i < intermediateValues.length; i++) {
                sum_k += intermediateValues[i];
            }
            var mean_k = sum_k / intermediateValues.length;

            var sumSqDiffK = 0;
            for (i = 0; i < intermediateValues.length; i++) {
                var diffVal = intermediateValues[i] - mean_k;
                sumSqDiffK += diffVal * diffVal;
            }
            var variance_k = sumSqDiffK / intermediateValues.length;

            var yMax = Math.ceil(maxAbsValue) + 1;
            var yMin = Math.floor(minAbsValue) - 1;
            var yRange = yMax - yMin;
            var yScale = plotHeight / yRange;

            var yZero = marginTop + plotHeight - ((0 - yMin) * yScale);

            // Y-axis
            ctx.beginPath();
            ctx.moveTo(marginLeft, marginTop);
            ctx.lineTo(marginLeft, marginTop + plotHeight);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.stroke();

            // X-axis
            ctx.beginPath();
            ctx.moveTo(marginLeft, yZero);
            ctx.lineTo(marginLeft + plotWidth, yZero);
            ctx.stroke();

            // Y-axis labels
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.font = '12px Arial';
            var yLabelStep = Math.ceil(yRange / 10);
            var yValue;
            for (yValue = yMin; yValue <= yMax; yValue += yLabelStep) {
                var yPos = marginTop + plotHeight - ((yValue - yMin) * yScale);
                ctx.beginPath();
                ctx.moveTo(marginLeft - 5, yPos);
                ctx.lineTo(marginLeft, yPos);
                ctx.stroke();
                ctx.fillText(yValue, marginLeft - 10, yPos);
            }

            // Draw trajectories
            var simIndex;
            for (simIndex = 0; simIndex < n; simIndex++) {
                ctx.strokeStyle = colors[simIndex];
                ctx.beginPath();
                var xPrev = marginLeft;
                var yPrev = marginTop + plotHeight - ((trajectories[simIndex][0] - yMin) * yScale);
                ctx.moveTo(xPrev, yPrev);

                for (step = 1; step <= m; step++) {
                    var xCurr = marginLeft + step * xStep;
                    var yCurr = marginTop + plotHeight - ((trajectories[simIndex][step] - yMin) * yScale);

                    ctx.lineTo(xCurr, yPrev);
                    ctx.lineTo(xCurr, yCurr);

                    xPrev = xCurr;
                    yPrev = yCurr;
                }
                ctx.stroke();
            }

            // Final distribution histogram
            var xStartFinalHistogram = marginLeft + plotWidth + 10;
            var histogramWidth = marginRight - 20;
            drawHistogramVersion2(ctx, finalValues, xStartFinalHistogram, marginTop, histogramWidth, plotHeight, yScale, yMin, yMax);

            // Intermediate distribution histogram
            var xAtK = marginLeft + k * xStep;
            var histogramWidthAtK = 0.15 * plotWidth;
            drawHistogramAtKVersion2(ctx, intermediateValues, xAtK + 5, marginTop, histogramWidthAtK, plotHeight, yScale, yMin, yMax);

            // Display mean/variance at step k
            ctx.fillStyle = 'black';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            var textX_k = xAtK + histogramWidthAtK / 2;
            var textY_k = marginTop + plotHeight + 20;
            ctx.fillText('Mean at k: ' + mean_k.toFixed(2), textX_k, textY_k);
            ctx.fillText('Variance at k: ' + variance_k.toFixed(2), textX_k, textY_k + 15);

            // Display mean/variance for final values
            var textX_final = xStartFinalHistogram + histogramWidth / 2;
            var textY_final = marginTop + plotHeight + 20;
            ctx.fillText('Mean: ' + mean.toFixed(2), textX_final, textY_final);
            ctx.fillText('Variance: ' + variance.toFixed(2), textX_final, textY_final + 15);
        }

        function drawHistogramVersion2(ctx, data, xStart, yStart, histogramWidth, plotHeight, yScale, yMin, yMax) {
            // Build frequencies
            var frequencies = {};
            var i;
            for (i = 0; i < data.length; i++) {
                var value = data[i];
                var bin = Math.round(value);
                if (frequencies[bin] === undefined) {
                    frequencies[bin] = 1;
                } else {
                    frequencies[bin] = frequencies[bin] + 1;
                }
            }

            // Find max frequency
            var maxFrequency = 0;
            var key;
            for (key in frequencies) {
                if (frequencies[key] > maxFrequency) {
                    maxFrequency = frequencies[key];
                }
            }

            // Draw histogram
            for (key in frequencies) {
                var freq = frequencies[key];
                var y = yStart + plotHeight - ((key - yMin) * yScale) - yScale / 2;
                var barHeight = yScale - 2;
                var barLength = 0;
                if (maxFrequency > 0) {
                    barLength = (freq / maxFrequency) * histogramWidth;
                }

                ctx.fillStyle = 'skyblue';
                ctx.fillRect(xStart, y - barHeight / 2, barLength, barHeight);
                ctx.strokeStyle = 'black';
                ctx.strokeRect(xStart, y - barHeight / 2, barLength, barHeight);
            }
        }

        function drawHistogramAtKVersion2(ctx, data, xStart, yStart, histogramWidth, plotHeight, yScale, yMin, yMax) {
            // Build frequencies
            var frequencies = {};
            var i;
            for (i = 0; i < data.length; i++) {
                var value = data[i];
                var bin = Math.round(value);
                if (frequencies[bin] === undefined) {
                    frequencies[bin] = 1;
                } else {
                    frequencies[bin] = frequencies[bin] + 1;
                }
            }

            // Find max frequency
            var maxFrequency = 0;
            var key;
            for (key in frequencies) {
                if (frequencies[key] > maxFrequency) {
                    maxFrequency = frequencies[key];
                }
            }

            // Draw histogram
            for (key in frequencies) {
                var freq = frequencies[key];
                var y = yStart + plotHeight - ((key - yMin) * yScale) - yScale / 2;
                var barHeight = yScale - 2;
                var barLength = 0;
                if (maxFrequency > 0) {
                    barLength = (freq / maxFrequency) * histogramWidth;
                }

                ctx.fillStyle = 'lightgreen';
                ctx.fillRect(xStart, y - barHeight / 2, barLength, barHeight);
                ctx.strokeStyle = 'black';
                ctx.strokeRect(xStart, y - barHeight / 2, barLength, barHeight);
            }
        }

        // ------------------- VERSION 3 (Poisson process) -------------------

        function runSimulationVersion3() {
            clearCanvas();

            var n = parseInt(document.getElementById('numSimulations').value);
            var m = parseInt(document.getElementById('numSteps').value) || 10000;
            var lambda = parseFloat(document.getElementById('lambda').value);
            var p = lambda / m;
            var k = parseInt(document.getElementById('intermediateStep').value);
            if (k > m) {
                k = m;
            }

            var marginLeft = 50;
            var marginRight = 150;
            var marginTop = 50;
            var marginBottom = 50;

            var plotWidth = canvas.width - marginLeft - marginRight;
            var plotHeight = canvas.height - marginTop - marginBottom;
            var xStep = plotWidth / m;

            var colors = [];
            var i;
            for (i = 0; i < n; i++) {
                var hue = (i * 360) / n;
                var colorStr = 'hsl(' + hue + ', 100%, 50%)';
                colors.push(colorStr);
            }

            var finalValues = [];
            var intermediateValues = [];

            var mean = 0;
            var delta = 0;
            var deviance = 0;

            var maxAbsValue = 0;
            var trajectories = [];

            var sim;
            for (sim = 0; sim < n; sim++) {
                var X = [];
                X[0] = 0;
                var step;
                for (step = 1; step <= m; step++) {
                    var randVal = Math.random();
                    var jump;
                    if (randVal < p) {
                        jump = 1;
                    } else {
                        jump = 0;
                    }
                    var Xnew = X[step - 1] + jump;
                    X[step] = Xnew;
                    if (Xnew > maxAbsValue) {
                        maxAbsValue = Xnew;
                    }
                }
                trajectories.push(X);

                finalValues.push(X[m]);
                intermediateValues.push(X[k]);

                var level = X[m];
                var countSoFar = sim + 1;
                delta = level - mean;
                mean = mean + (delta / countSoFar);
                deviance = deviance + (delta * (level - mean));
            }

            var variance = deviance / n;

            var sum_k = 0;
            for (i = 0; i < intermediateValues.length; i++) {
                sum_k += intermediateValues[i];
            }
            var mean_k = sum_k / intermediateValues.length;

            var sumSqDiffK = 0;
            for (i = 0; i < intermediateValues.length; i++) {
                var diffVal = intermediateValues[i] - mean_k;
                sumSqDiffK += diffVal * diffVal;
            }
            var variance_k = sumSqDiffK / intermediateValues.length;

            var yMax = Math.ceil(maxAbsValue) + 1;
            var yMin = 0;
            var yRange = yMax - yMin;
            var yScale = plotHeight / yRange;
            var yZero = marginTop + plotHeight;

            // Y-axis
            ctx.beginPath();
            ctx.moveTo(marginLeft, marginTop);
            ctx.lineTo(marginLeft, marginTop + plotHeight);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.stroke();

            // X-axis
            ctx.beginPath();
            ctx.moveTo(marginLeft, yZero);
            ctx.lineTo(marginLeft + plotWidth, yZero);
            ctx.stroke();

            // Y-axis labels
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.font = '12px Arial';
            var yLabelStep = Math.ceil(yRange / 10);
            var yValue;
            for (yValue = yMin; yValue <= yMax; yValue += yLabelStep) {
                var yPos = marginTop + plotHeight - ((yValue - yMin) * yScale);
                ctx.beginPath();
                ctx.moveTo(marginLeft - 5, yPos);
                ctx.lineTo(marginLeft, yPos);
                ctx.stroke();
                ctx.fillText(yValue, marginLeft - 10, yPos);
            }

            // Draw trajectories
            var s;
            for (s = 0; s < n; s++) {
                ctx.strokeStyle = colors[s];
                ctx.beginPath();
                var xPrev = marginLeft;
                var yPrev = marginTop + plotHeight - ((trajectories[s][0] - yMin) * yScale);
                ctx.moveTo(xPrev, yPrev);

                for (step = 1; step <= m; step++) {
                    var xCurr = marginLeft + step * xStep;
                    var yCurr = marginTop + plotHeight - ((trajectories[s][step] - yMin) * yScale);

                    ctx.lineTo(xCurr, yPrev);
                    ctx.lineTo(xCurr, yCurr);

                    xPrev = xCurr;
                    yPrev = yCurr;
                }
                ctx.stroke();
            }

            // X-axis label at the end
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.font = '12px Arial';
            var xLabel = m;
            var xPos = marginLeft + plotWidth;
            var yPos = yZero + 5;
            ctx.fillText(xLabel, xPos, yPos);

            // Final distribution histogram
            var xStartFinalHistogram = marginLeft + plotWidth + 10;
            var histogramWidth = marginRight - 20;
            drawHistogramVersion3(ctx, finalValues, xStartFinalHistogram, marginTop, histogramWidth, plotHeight, yScale, yMin, yMax);

            // Intermediate distribution histogram
            var xAtK = marginLeft + k * xStep;
            var histogramWidthAtK = 0.15 * plotWidth;
            drawHistogramAtKVersion3(ctx, intermediateValues, xAtK + 5, marginTop, histogramWidthAtK, plotHeight, yScale, yMin, yMax);

            // Display mean/variance at k
            ctx.fillStyle = 'black';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            var textX_k = xAtK + histogramWidthAtK / 2;
            var textY_k = marginTop + plotHeight + 20;
            ctx.fillText('Mean at k: ' + mean_k.toFixed(2), textX_k, textY_k);
            ctx.fillText('Variance at k: ' + variance_k.toFixed(2), textX_k, textY_k + 15);

            // Display mean/variance final
            var textX_final = xStartFinalHistogram + histogramWidth / 2;
            var textY_final = marginTop + plotHeight + 20;
            ctx.fillText('Mean: ' + mean.toFixed(2), textX_final, textY_final);
            ctx.fillText('Variance: ' + variance.toFixed(2), textX_final, textY_final + 15);
        }

        function drawHistogramVersion3(ctx, data, xStart, yStart, histogramWidth, plotHeight, yScale, yMin, yMax) {
            // Build frequencies
            var frequencies = {};
            var i;
            for (i = 0; i < data.length; i++) {
                var value = data[i];
                var bin = Math.round(value);
                if (frequencies[bin] === undefined) {
                    frequencies[bin] = 1;
                } else {
                    frequencies[bin] = frequencies[bin] + 1;
                }
            }

            // Find max frequency
            var maxFrequency = 0;
            var key;
            for (key in frequencies) {
                if (frequencies[key] > maxFrequency) {
                    maxFrequency = frequencies[key];
                }
            }

            // Draw histogram
            for (key in frequencies) {
                var freq = frequencies[key];
                var y = yStart + plotHeight - ((key - yMin) * yScale) - yScale / 2;
                var barHeight = yScale - 2;
                var barLength = 0;
                if (maxFrequency > 0) {
                    barLength = (freq / maxFrequency) * histogramWidth;
                }

                ctx.fillStyle = 'skyblue';
                ctx.fillRect(xStart, y - barHeight / 2, barLength, barHeight);
                ctx.strokeStyle = 'black';
                ctx.strokeRect(xStart, y - barHeight / 2, barLength, barHeight);
            }
        }

        function drawHistogramAtKVersion3(ctx, data, xStart, yStart, histogramWidth, plotHeight, yScale, yMin, yMax) {
            var frequencies = {};
            var i;
            for (i = 0; i < data.length; i++) {
                var value = data[i];
                var bin = Math.round(value);
                if (frequencies[bin] === undefined) {
                    frequencies[bin] = 1;
                } else {
                    frequencies[bin] = frequencies[bin] + 1;
                }
            }

            var maxFrequency = 0;
            var key;
            for (key in frequencies) {
                if (frequencies[key] > maxFrequency) {
                    maxFrequency = frequencies[key];
                }
            }

            for (key in frequencies) {
                var freq = frequencies[key];
                var y = yStart + plotHeight - ((key - yMin) * yScale) - yScale / 2;
                var barHeight = yScale - 2;
                var barLength = 0;
                if (maxFrequency > 0) {
                    barLength = (freq / maxFrequency) * histogramWidth;
                }

                ctx.fillStyle = 'lightgreen';
                ctx.fillRect(xStart, y - barHeight / 2, barLength, barHeight);
                ctx.strokeStyle = 'black';
                ctx.strokeRect(xStart, y - barHeight / 2, barLength, barHeight);
            }
        }

        // ------------------- VERSION 4 (Brownian motion) -------------------

        function runSimulationVersion4() {
            clearCanvas();

            var n = parseInt(document.getElementById('numSimulations').value);
            var m = parseInt(document.getElementById('numSteps').value) || 10000;
            var p = parseFloat(document.getElementById('probabilityP').value);
            var k = parseInt(document.getElementById('intermediateStep').value);
            if (k > m) {
                k = m;
            }

            var marginLeft = 50;
            var marginRight = 150;
            var marginTop = 50;
            var marginBottom = 50;

            var plotWidth = canvas.width - marginLeft - marginRight;
            var plotHeight = canvas.height - marginTop - marginBottom;
            var xStep = plotWidth / m;

            var colors = [];
            var i;
            for (i = 0; i < n; i++) {
                var hue = (i * 360) / n;
                var colorStr = 'hsl(' + hue + ', 100%, 50%)';
                colors.push(colorStr);
            }

            var finalValues = [];
            var intermediateValues = [];

            var maxAbsValue = 0;
            var trajectories = [];

            var dt = 1.0 / m;

            var sim;
            for (sim = 0; sim < n; sim++) {
                var X = [];
                X[0] = 0;
                var step;
                for (step = 1; step <= m; step++) {
                    var randVal = Math.random();
                    var jump;
                    if (randVal <= p) {
                        jump = Math.sqrt(dt);
                    } else {
                        jump = -Math.sqrt(dt);
                    }
                    var Xnew = X[step - 1] + jump;
                    X[step] = Xnew;

                    if (Math.abs(Xnew) > maxAbsValue) {
                        maxAbsValue = Math.abs(Xnew);
                    }
                }
                trajectories.push(X);

                finalValues.push(X[m]);
                intermediateValues.push(X[k]);
            }

            // Mean/variance finalValues
            var sumVal = 0;
            var j;
            for (j = 0; j < finalValues.length; j++) {
                sumVal += finalValues[j];
            }
            var mean = sumVal / finalValues.length;

            var sumSq = 0;
            for (j = 0; j < finalValues.length; j++) {
                var diff = finalValues[j] - mean;
                sumSq += diff * diff;
            }
            var variance = sumSq / finalValues.length;

            // Mean/variance intermediateValues
            var sumValK = 0;
            for (j = 0; j < intermediateValues.length; j++) {
                sumValK += intermediateValues[j];
            }
            var mean_k = sumValK / intermediateValues.length;

            var sumSqK = 0;
            for (j = 0; j < intermediateValues.length; j++) {
                var diffK = intermediateValues[j] - mean_k;
                sumSqK += diffK * diffK;
            }
            var variance_k = sumSqK / intermediateValues.length;

            var yMax = maxAbsValue + 1;
            var yMin = -maxAbsValue - 1;
            var yRange = yMax - yMin;
            var yScale = plotHeight / yRange;

            var yZero = marginTop + plotHeight - (-yMin * yScale);

            // Y-axis
            ctx.beginPath();
            ctx.moveTo(marginLeft, marginTop);
            ctx.lineTo(marginLeft, marginTop + plotHeight);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.stroke();

            // X-axis
            ctx.beginPath();
            ctx.moveTo(marginLeft, yZero);
            ctx.lineTo(marginLeft + plotWidth, yZero);
            ctx.stroke();

            // Y-axis labels
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.font = '12px Arial';
            var yLabelStep = yRange / 10;
            var yValue = yMin;
            while (yValue <= yMax) {
                var yPos = yZero - (yValue * yScale);
                ctx.beginPath();
                ctx.moveTo(marginLeft - 5, yPos);
                ctx.lineTo(marginLeft, yPos);
                ctx.stroke();
                ctx.fillText(yValue.toFixed(2), marginLeft - 10, yPos);
                yValue += yLabelStep;
            }

            // Draw trajectories
            var s;
            for (s = 0; s < n; s++) {
                ctx.strokeStyle = colors[s];
                ctx.beginPath();
                var xPrev = marginLeft;
                var yPrev = yZero - (trajectories[s][0] * yScale);
                ctx.moveTo(xPrev, yPrev);

                for (step = 1; step <= m; step++) {
                    var xCurr = marginLeft + step * xStep;
                    var yCurr = yZero - (trajectories[s][step] * yScale);
                    ctx.lineTo(xCurr, yCurr);

                    xPrev = xCurr;
                    yPrev = yCurr;
                }
                ctx.stroke();
            }

            // Final distribution histogram
            var xStartFinalHistogram = marginLeft + plotWidth + 10;
            var histogramWidth = marginRight - 20;
            drawHistogramVersion4(ctx, finalValues, xStartFinalHistogram, marginTop, histogramWidth, plotHeight, yScale, yMin, yMax);

            // Intermediate distribution histogram
            var xAtK = marginLeft + k * xStep;
            var histogramWidthAtK = 0.15 * plotWidth;
            drawHistogramAtKVersion4(ctx, intermediateValues, xAtK + 5, marginTop, histogramWidthAtK, plotHeight, yScale, yMin, yMax);

            // Display mean and variance at step k
            ctx.fillStyle = 'black';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            var textX_k = xAtK + (histogramWidthAtK / 2);
            var textY_k = marginTop + plotHeight + 20;
            ctx.fillText('Mean at k: ' + mean_k.toFixed(4), textX_k, textY_k);
            ctx.fillText('Variance at k: ' + variance_k.toFixed(6), textX_k, textY_k + 15);

            // Display mean and variance for final values
            var textX_final = xStartFinalHistogram + (histogramWidth / 2);
            var textY_final = marginTop + plotHeight + 20;
            ctx.fillText('Mean: ' + mean.toFixed(4), textX_final, textY_final);
            ctx.fillText('Variance: ' + variance.toFixed(6), textX_final, textY_final + 15);
        }

        function drawHistogramVersion4(ctx, data, xStart, yStart, histogramWidth, plotHeight, yScale, yMin, yMax) {
            var desiredBarWidth = 2;
            var numberOfBins = Math.floor(plotHeight / desiredBarWidth);
            var binWidth = (yMax - yMin) / numberOfBins;

            var frequencies = [];
            var i;
            for (i = 0; i < numberOfBins; i++) {
                frequencies[i] = 0;
            }

            var j;
            for (j = 0; j < data.length; j++) {
                var val = data[j];
                var binIndex = Math.floor((val - yMin) / binWidth);
                if (binIndex >= 0 && binIndex < numberOfBins) {
                    frequencies[binIndex] = frequencies[binIndex] + 1;
                }
            }

            var maxFrequency = 0;
            for (i = 0; i < frequencies.length; i++) {
                if (frequencies[i] > maxFrequency) {
                    maxFrequency = frequencies[i];
                }
            }

            for (i = 0; i < numberOfBins; i++) {
                var freq = frequencies[i];
                var yBinValue = yMin + i * binWidth;
                var yCoordCenter = yStart + plotHeight - ((yBinValue - yMin) * yScale) - (binWidth * yScale) / 2;
                var barHeight = binWidth * yScale;
                var barLength = 0;
                if (maxFrequency > 0) {
                    barLength = (freq / maxFrequency) * histogramWidth;
                }

                ctx.fillStyle = 'skyblue';
                ctx.fillRect(xStart, yCoordCenter - (barHeight / 2), barLength, barHeight);
                ctx.strokeStyle = 'black';
                ctx.strokeRect(xStart, yCoordCenter - (barHeight / 2), barLength, barHeight);
            }
        }

        function drawHistogramAtKVersion4(ctx, data, xStart, yStart, histogramWidth, plotHeight, yScale, yMin, yMax) {
            var desiredBarWidth = 2;
            var numberOfBins = Math.floor(plotHeight / desiredBarWidth);
            var binWidth = (yMax - yMin) / numberOfBins;

            var frequencies = [];
            var i;
            for (i = 0; i < numberOfBins; i++) {
                frequencies[i] = 0;
            }

            var j;
            for (j = 0; j < data.length; j++) {
                var val = data[j];
                var binIndex = Math.floor((val - yMin) / binWidth);
                if (binIndex >= 0 && binIndex < numberOfBins) {
                    frequencies[binIndex] = frequencies[binIndex] + 1;
                }
            }

            var maxFrequency = 0;
            for (i = 0; i < frequencies.length; i++) {
                if (frequencies[i] > maxFrequency) {
                    maxFrequency = frequencies[i];
                }
            }

            for (i = 0; i < numberOfBins; i++) {
                var freq = frequencies[i];
                var yBinValue = yMin + i * binWidth;
                var yCoordCenter = yStart + plotHeight - ((yBinValue - yMin) * yScale) - (binWidth * yScale) / 2;
                var barHeight = binWidth * yScale;
                var barLength = 0;
                if (maxFrequency > 0) {
                    barLength = (freq / maxFrequency) * histogramWidth;
                }

                ctx.fillStyle = 'lightgreen';
                ctx.fillRect(xStart, yCoordCenter - (barHeight / 2), barLength, barHeight);
                ctx.strokeStyle = 'black';
                ctx.strokeRect(xStart, yCoordCenter - (barHeight / 2), barLength, barHeight);
            }
        }

        // ------------------- VERSION SELECT -------------------

        document.getElementById('versionSelect').addEventListener('change', function() {
            var selectedVersion = this.value;
            switch (selectedVersion) {
                case '1':
                    setupVersion1();
                    break;
                case '2':
                    setupVersion2();
                    break;
                case '3':
                    setupVersion3();
                    break;
                case '4':
                    setupVersion4();
                    break;
            }
        });

        // Set up default version
        setupVersion1();
    </script>
</body>
</html>
